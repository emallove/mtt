#!/usr/bin/env perl
#
# Copyright (c) 2005-2006 The Trustees of Indiana University.
#                         All rights reserved.
# $COPYRIGHT$
# 
# Additional copyrights may follow
# 
# $HEADER$
#

use strict;

use Data::Dumper;
use Getopt::Long;
use File::Basename;
use Cwd;
use POSIX qw(strftime);

# Try to find the MTT files.  Assume that mtt executable is in the
# base directory for the MTT files.  Try three methods:

# 1. With no effort; see if we can just "require" and find MTT files.
# 2. If $0 is a path, try adding that do @INC and try "require" again.
# 3. Otherwise, search $ENV[PATH] for mtt, and when you find it, add
#    that directory to @INC and try again.

use lib cwd() . "/lib";

my $ret;
eval "\$ret = require MTT::Version";
if (1 != $ret) {
    my $dir = dirname($0);
    my @INC_save = @INC;

    # Change to the dir of $0 (because it might be a relative
    # directory) and add the cwd() to @INC
    my $start_dir = cwd();
    chdir($dir);
    chdir("..");
    push(@INC, cwd() . "/lib");
    chdir($start_dir);
    eval "\$ret = require MTT::Version";

    # If it didn't work, restore @INC and try looking for mtt in the
    # path

    if (1 != $ret) {
        @INC = @INC_save;
        my @dirs = split(/:/, $ENV{PATH});
        my $mtt = basename($0);
        foreach my $dir (@dirs) {

            # If we found the mtt executable, add the dir to @INC and
            # see if we can "require".  If require fails, restore @INC
            # and keep trying.
            if (-x "$dir/$mtt") {
                chdir($dir);
                chdir("..");
                push(@INC, cwd() . "/lib");
                chdir($start_dir);
                eval "\$ret = require MTT::Version";
                if (1 == $ret) {
                    last;
                } else {
                    @INC = @INC_save;
                }
            }
        }
    }

    # If we didn't find them, die.
    die "Unable to find MTT support libraries"
        if (0 == $ret);
}

# Must use "require" (run-time) for all of these, not "use"
# (compile-time)

require Config::IniFiles;
require MTT::Version;
require MTT::MPI;
require MTT::Test;
require MTT::Files;
require MTT::Messages;
require MTT::INI;
require MTT::Reporter;
require MTT::Defaults;
require MTT::Globals;
require MTT::FindProgram;
require MTT::Trim;

my @file_arg;
my $stdin_arg;
my $scratch_arg;
my $help_arg;
my $debug_arg;
my $verbose_arg;
my $force_arg;
my $mpi_get_arg;
my $mpi_install_arg;
my $test_get_arg;
my $test_build_arg;
my $test_run_arg;
my $trim_arg;
my $version_arg;
my $ini_args;
my $time_arg;

my @SAVE_ARGV = @ARGV;

&Getopt::Long::Configure("bundling");
my $ok = Getopt::Long::GetOptions("file|f=s" => \@file_arg,
                                  "" => \$stdin_arg,
                                  "scratch|s=s" => \$scratch_arg,
                                  "help|h" => \$help_arg,
                                  "debug|d" => \$debug_arg,
                                  "verbose|v" => \$verbose_arg,
                                  "force" => \$force_arg,
                                  "mpi-get!" => \$mpi_get_arg,
                                  "mpi-install!" => \$mpi_install_arg,
                                  "test-get!" => \$test_get_arg,
                                  "test-build!" => \$test_build_arg,
                                  "test-run!" => \$test_run_arg,
                                  "trim!" => \$trim_arg,
                                  "version" => \$version_arg,
                                  "print-time|p" => \$time_arg,
                                  );
# Everything ok?

if ($version_arg) {
    print "MTT Version $MTT::Version::Major.$MTT::Version::Minor\n";
    exit(0);
}

foreach my $file (@ARGV) {
    push(@file_arg, $file) 
        if (-T $file and $file =~ /\.ini\s*$/);
}

# Get command-line overridden ini params
my $key_val_regexp = '([^=]+)\=(.*)';
foreach my $arg (@ARGV) {
    if ($arg =~ /([^:]+)\:$key_val_regexp$/) {
        $ini_args->{$2}->{value} = $3; 
        $ini_args->{$2}->{match} = $1; 
    }
    elsif ($arg =~ /$key_val_regexp$/) {
        $ini_args->{$1}->{value} = $2; 
        $ini_args->{$1}->{match} = '.'; 
    }
}
if (! @file_arg and ! $stdin_arg) {
    print "Must specify at least one --file argument or '-' for stdin.\n";
    $ok = 0;
}
if ($file_arg[0] eq "-" or $stdin_arg) {
    $stdin_arg = 1;
    $file_arg[0] = undef;
    open($file_arg[0], "-");
}
if (!$ok || $help_arg) {
    print("Command line error\n") 
        if (!$ok);
    print "Options:
--file|-f <config_file>       Specify the configuration file
--scratch|-s <dir_name>       Scratch directory (where all work is done)
--help|-h                     This message
--debug|-d                    Output lots of debug messages
--verbose|-v                  Output some status / verbose messages
                              while processing
--print-time|-p               Display the amount of time taken in each phase
--force                       Do steps even if they would not normally
                              be executed
--[no-]mpi-get                Do the \"MPI get\" phase
--[no-]mpi-install            Do the \"MPI install\" phase
--[no-]test-get               Do the \"Test get\" phase
--[no-]test-build             Do the \"Test build\" phase
--[no-]test-run               Do the \"Test run\" phase
--[no-]trim                   Do the \"Trim\" phase
field=value                   Replace parameter \"foo\" from the INI file
                              with the value \"bar\" (i.e., override the
                              INI file value)

If no options other than --file, -f, or '-' are specified, the MTT
will default to trying to make as much progress as possible (i.e.,
running each of the phases as necessary).  For example, to set
'save_stdout_on_success' in every section:

    \$ client/mtt [...] save_stdout_on_success=1

To set 'intel_ompi_tests_fflags' in only the [test build: intel]
section (note the shell quoting to include the spaces in the value):

    \$ client/mtt [...] 'build,intel:intel_ompi_tests_fflags=-g -odd_ball_flag'

The phases can be specified in positive or negative form.  You can
only specify positive or negative phases in a run; you cannot mix both
positive and negative phases in a single MTT run.

* If any phases are specified in the positive form, then only those
  phases will be run (e.g., \"--mpi-get --mpi-install\").
* If negative phases are specified, then thoses phases will *not* be
  run.\n";

    exit($ok);
}

# Check debug

my $debug = ($debug_arg ? 1 : 0);
my $verbose = ($verbose_arg ? 1 : $debug);
MTT::Messages::Messages($debug, $verbose);
MTT::Messages::Debug("Debug is $debug, Verbose is $verbose\n");
MTT::Messages::Verbose("*** MTT: $0 @SAVE_ARGV\n");

MTT::FindProgram::FindZeroDir();

########################################################################
# Params
########################################################################

# See if we got a scratch root
if (! $scratch_arg) {
    $scratch_arg = ".";
}
MTT::Messages::Debug("Scratch: $scratch_arg\n");
if (! -d $scratch_arg) {
    MTT::Files::mkdir($scratch_arg, 0777);
}
if (! -d $scratch_arg) {
    MTT::Messages::Abort("Could not make scratch dir: $scratch_arg\n");
}
chdir($scratch_arg);
$scratch_arg = cwd();
MTT::Messages::Debug("Scratch resolved: $scratch_arg\n");

# If any of the --get-mpi, --install-mpi, --build-tests, or
# --run-tests are specified, then their defaults all go to 0.
# Otherwise, if none are specified, they all default to 1.

my $mpi_get = 1;
my $mpi_install = 1;
my $test_get = 1;
my $test_build = 1;
my $test_run = 1;
my $trim = 1;

if (defined($mpi_get_arg) || defined($mpi_install_arg) ||
    defined($test_get_arg) || defined($test_build_arg) || 
    defined($test_run_arg) || defined($trim_arg)) {

    # If anything is defined as "yes", then only do those

    if ($mpi_get_arg || $mpi_install_arg || 
        $test_get_arg || $test_build_arg || $test_run_arg ||
        $trim_arg) {

        $mpi_get = $mpi_install = $test_get = $test_build = $test_run = $trim = 0;

        $mpi_get = 1 if defined($mpi_get_arg) && $mpi_get_arg;
        $mpi_install = 1 if defined($mpi_install_arg) && $mpi_install_arg;
        $test_get = 1 if defined($test_get_arg) && $test_get_arg;
        $test_build = 1 if defined($test_build_arg) && $test_build_arg;
        $test_run = 1 if defined($test_run_arg) && $test_run_arg;
        $trim = 1 if defined($trim_arg) && $trim_arg;
    } 

    # Otherwise, just negate whatever option was negated

    else {
        $mpi_get = 0 if defined($mpi_get_arg) && !$mpi_get_arg;
        $mpi_install = 0 if defined($mpi_install_arg) && !$mpi_install_arg;
        $test_get = 0 if defined($test_get_arg) && !$test_get_arg;
        $test_build = 0 if defined($test_build_arg) && !$test_build_arg;
        $test_run = 0 if defined($test_run_arg) && !$test_run_arg;
        $trim = 0 if defined($trim_arg) && !$trim_arg;
    }
}

########################################################################
# Load up all old data
########################################################################

# Make directories
my $source_dir = 
    MTT::Files::mkdir("$scratch_arg/$MTT::Defaults::System_config->{source_subdir}");
my $install_dir = 
    MTT::Files::mkdir("$scratch_arg/$MTT::Defaults::System_config->{install_subdir}");

# Load up all the MPI sources that this system has previously obtained
MTT::MPI::LoadSources($source_dir)
    if ($mpi_get || $mpi_install || $trim);

# Load up all the installs of the MPI sources
MTT::MPI::LoadInstalls($install_dir)
    if ($mpi_install || $test_build || $test_run || $trim);

# Load up the test sources for each install
MTT::Test::LoadSources($source_dir)
    if ($test_get || $test_build || $test_run || $trim);

# Load up the built tests for each install
MTT::Test::LoadBuilds($install_dir)
    if ($test_build || $test_run || $trim);

# Load up the run tests for each install
MTT::Test::LoadRuns($install_dir)
    if ($test_run || $trim);


########################################################################
# Timekeeping
########################################################################

my $start_timestamp_string;
my $start_timestamp_data;
my $start_timestamp_first_string;
my $start_timestamp_first_data;
sub start_time {
    if (!defined($start_timestamp_string)) {
        $start_timestamp_first_string = $start_timestamp_string = localtime;
        $start_timestamp_first_data = $start_timestamp_data = time;
    } else {
        $start_timestamp_string = localtime;
        $start_timestamp_data = time;
    }
}

sub timestamp_sub {
    my ($start, $stop) = @_;
    my ($days, $hours, $mins, $secs);

    # Constants
    my $m = 60;
    my $h = $m * 60;
    my $d = $h * 24;

    # Baseline difference
    my $elapsed = $stop - $start;

    # Individual components
    if ($elapsed > $d) {
        use integer;
        $days = $elapsed / $d;
        $elapsed -= $days * $d;
    } else {
        $days = 0;
    }

    if ($elapsed > $h) {
        use integer;
        $hours = $elapsed / $h;
        $elapsed -= $hours * $h;
    } else {
        $hours = 0;
    }

    if ($elapsed > $m) {
        use integer;
        $mins = $elapsed / $m;
        $elapsed -= $mins * $m;
    } else {
        $mins = 0;
    }

    my $secs = $elapsed;

    my $elapsed_string = sprintf("%02d:%02d:%02d", $hours, $mins, $secs);
    if ($days > 0) {
        $elapsed_string = "$days days, $elapsed_string";
    }
    return $elapsed_string;
}

sub stop_time {
    my $name = shift;
    if ($time_arg) {
        my $stop_timestamp_string = localtime;
        my $stop_timestamp_data = time;

        my $elapsed_string = timestamp_sub($start_timestamp_data, 
                                           $stop_timestamp_data);
        my $total_elapsed_string = timestamp_sub($start_timestamp_first_data,
                                                 $stop_timestamp_data);

        print ">> Phase: $name
   Started:       $start_timestamp_string
   Stopped:       $stop_timestamp_string
   Elapsed:       $elapsed_string
   Total elapsed: $total_elapsed_string\n";
    }
}

########################################################################
# Read the ini file(s)
########################################################################

foreach my $file (@file_arg) {
    
    # Load up the ini file

    MTT::Messages::Debug("Reading ini file: " . (($stdin_arg) ? "stdin" : $file) . "\n");
    my $ini = new Config::IniFiles(-file => $file, 
                                   -nocase => 1,
                                   -allowcontinue => 1);

    # Override ini file params with those supplied at command-line

    $ini = MTT::INI::OverrideINIParams($ini, $ini_args);

    if (! $ini) {
        MTT::Messages::Warning("Could not read INI file: $file; skipping\n");
        next;
    }

    # Examine the [MTT] global defaults section

    MTT::Globals::load($ini);

    # Run the phases

    MTT::Reporter::Init($ini);

    if ($mpi_get) {
        start_time();
        MTT::MPI::Get($ini, $source_dir, $force_arg);
        stop_time("MPI Get");
    }
    if ($mpi_install) {
        start_time();
        MTT::MPI::Install($ini, $install_dir, $force_arg);
        stop_time("MPI Install");
    }
    if ($test_get) {
        start_time();
        MTT::Test::Get($ini, $source_dir, $force_arg);
        stop_time("Test Get");
    }
    if ($test_build) {
        start_time();
        MTT::Test::Build($ini, $install_dir, $force_arg);
        stop_time("Test Build");
    }
    if ($test_run) {
        start_time();
        MTT::Test::Run($ini, $install_dir, $force_arg);
        stop_time("Test Run");
    }

    # Remove old sources, installs, and builds

    if ($trim) {
        start_time();
        MTT::Trim::Trim($ini);
        stop_time("Trim");
    }

    # Shutdown the reporter

    MTT::Reporter::Finalize();
}

# That's it!

exit(0);
